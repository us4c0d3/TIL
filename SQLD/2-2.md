# 핵심 정리

- 오라클에서 공백 문자 데이터는 NULL로 저장
- 오라클에서 DATE 산술연산 시 1은 하루(=24H=24\*60min=24\*60*60sec)
- DECODE 함수
  - DECODE(A, B, X, Y): A=B이면 X, A != B이면 Y
  - DECODE(A, B, X, C, Y, Z): A = B이면 X, A = C이면 Y, A!=B, A!=C이면 Z

### SQL 연산 순서

1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

#### SQL 분류

- DML: SELECT, INSERT, UPDATE, DELETE
- DDL: CREATE, DROP, ALTER, MODIFY
- TCL: ROLLBACK, COMMIT
- DCL: GRANT, REVOKE



### CONCAT

SQL Server

- SELECT col1 + col2 + col3 FROM table;

Oracle

- SELECT col1 || col2 || col3 FROM table;

> SELECT concat(col1, col2) FROM table; concat은 연산자 2개만 가능



### NULL 처리

  - NULLIF(A, B): 두 개의 값이 같으면 NULL, 다르면 A 반환
  - NVL(A, B): A가 NULL이면 B 반환, 아니면 NULL반환
  - NVL2(A, B, C): A가 NULL이 아니면 B반환, NULL이면 C반환
  - COALESCE(A, B): A와 B 둘 중 하나가 NULL이라면 NULL이 아닌 값 반환, 둘 다 NULL이라면 NULL반환, 둘 다 NULL이 아니라면 A 반환

### 순수관계연산자

  - SELECT
  - PROJECT
  - JOIN
  - DIVIDE

### NULL

- 산술 연산에서 null이 들어가게 되면 null 출력
- 조건절에 null이 들어가면 false 반환
- 집계함수에서 null은 데이터 대상에서 제외



### JOIN

- Cartesian Product(카테시안 곱): 일명 x 연산. 모든 조합이 레코드화 되서 출력

![](.\images\sql_joins.png)



### USING 절

- EQUI JOIN 시 동일한 컬럼명을 가질 때 사용 가능

- 이 경우 테이블 alias 사용 불가

- ```sql
  SELECT T.REGION_NAME, T.TEAM_NAME, STADIUM_ID, S.STADIUM_NAME
  FROM TEAM T INNER JOIN STADIUM S
  	USING (STADIUM_ID);
  ```

  ```sql
  SELECT T.REGION_NAME, T.TEAM_NAME, T.STADIUM_ID, S.STADIUM_NAME
  FROM TEAM T INNER JOIN STADIUM S
  	ON T.STADIUM_ID=S.STADIUM_ID;
  ```

- 위 두 쿼리문은 동일한 실행결과 제공



### UNION

- UNION: 중복 제거
- UNION ALL: 중복된 데이터를 제거하지 않고 모든 데이터 반환
- ROLLUP(cols...): cols에 관한 각각의 소그룹 집계와 전체 집계를 모두 반환. 단, 왼쪽에서 오른쪽으로 계층적으로 누적 집계 생성
  - ex) ROLLUP(a, b, c) -> (a, b, c), (a, b), (a), (전체)

- CUBE(cols...): ROLLUP과 유사하나 모든 cols 각각에 관한 소그룹 조합에 대한 집계 반환 및 전체 집계 반환. 즉 n개의 컬럼이 있다면 2^n개의 그룹을 모두 반환
- GROUPING SETS(cols...): 각 소그룹 별 합계만 제공.
  - ex) GROUPING SETS(a, (a, b)): a에 관한 집계와 (a, b)에 관한 집계 반환

- 



### Oracle (+)

- Left Outer Join 또는 Right Outer Join을 의미

- `(+)`가 붙은 쪽이 데이터가 없어도 NULL을 채워서 결과에 포함

- ```sql
  SELECT A.ID A.NAME
  FROM A B
  WHERE A.ID = B.ID(+)
  AND B.atr1(+) = 'N'
  AND A.atr2 = 'Y'
  ```

  ```sql
  SELECT A.ID A.NAME
  FROM A LEFT OUTER JOIN B
  ON (A.ID = B.ID AND B.atr1 = 'N')
  WHERE A.atr2 = 'Y'
  ```

- 위 두 쿼리문은 동일한 실행결과 제공



### 연산자

- A BETWEEN B AND C: B <= A <= C
- A IN (1, 2, 3): A = 1 OR A = 2 OR A = 3
- A LIKE '_ble%': A의 값 중 2, 3, 4번째 값이 ble인 모든 데이터 출력
  - '_'는 1개 이상, '%'는 0개 이상



### row 개수

- Oracle - WHERE 옆에 ROWNUM
  - WHERE ROWNUM <= 3; 무조건 부등식; 3개만 나옴
- SQL Server - SELECT 옆에 TOP
  - SELECT TOP(3); 3개만 나옴



### PARTITION BY ... ORDER BY

- OVER: 집계 함수를 윈도우 함수로 확장해서 그룹 단위가 아니라 행마다 결과를 부여줄 수 있게 함
- PARTITION BY: 데이터를 소그룹으로 나누는 역할
- 따라서 `함수() OVER (PARTITION BY ... ORDER BY ...)`형태로 쓰면, `파티션별로 나눠서, 그 안에서의 순위, 누적, 집계`등을 구할 수 있음
- `SUM(급여) OVER (PARTITION BY 부서코드)`: 같은 부서에 속한 모든 행에 동일한 합계 값이 표시
- `SUM(급여) OVER (PARTITION BY 부서코드 ORDER BY 사원코드)`: 같은 부서 내에서 사원번호 기준으로 정렬하면서 그 시점까지의 급여 합계가 각 행에 출력; 누적합 표시; 윈도우가 점점 확장되는 형태



### START WITH ... CONNECT BY ... ORDER SIBLINGS BY ...

- START WITH
  - 계층 구조의 시작점. 어떤 행부터 탐색을 시작할 것인지 정의
- CONNECT BY
  - 계층적으로 부모-자식 관계를 지정
  - PRIOR키워드를 사용. PRIOR이 부모쪽 컬림
  - 등호의 의미 무시하지 않기
- ORDER SIBILINGS BY
  - 같은 형제 관계에서 정렬 순서



### RANK

- PERCENT_RANK(): 상대적 백분위를 나타냄. 0~1의 값
- CUME_DIST(): PERCENT_RANK의 누적값
- RANK(): 동일한 값이면 중복순위 부여. 다음 순위는 해당 순위만큼 건너뜀
- DENSE_RANK(): 동일한 값 중복순위 부여. 다음 순위는 순차대로 부여
- ROW_NUMBER(): 중복 상관없이 순차 부여
- NTILE(n): 전체 행을 n개의 그룹으로 나눠서 숫자 부여. 나머지가 있다면 우선 그룹을 나눈 후 나머지는 한 개씩 부여



### 서브쿼리

- 서브쿼리는 단일 행 또는 복수 행 비교 연산자와 함께 사용할 수 있다.
- 서브쿼리는 select절, from절, having절, order by 절 등에서 사용 가능
- 연관 서브쿼리는 서브쿼리가 메인쿼리 컬럼을 포함하고 있는 형태의 서브쿼리
- 단일행 서브쿼리: 리턴값이 1개 이하인 서브쿼리; 스칼라 서브쿼리라고도 함
- 다중행 서브쿼리: 리턴값이 여러행



### UNBOUNDED PRECEDING

- ROWS UNBOUNDED PRECEDING: 현재 행과 행 위에 있는 데이터를 사용하여라
- RANGE UNBOUNDED PRECEDING: 현재 값을 기준으로 이하인 값을 사용하여라



### LAG, LEAD

- LAG(a, b, c): 컬럼 a를 기준으로 현재 값의 이전 b번째 값을 가져오고 해당 값이 존재하지 않는다면 c를 기본값으로 한다. b와 c는 생략가능하며, 생략 시 b는 1이고 c는 null이다.
- LEAD(a, b, c): LAG와 구조는 동일. 이후 b번째 값을 가져옴



### PIVOT, UNPIVOT

- PIVOT: 행을 열로 바꿈. 헷갈리니까 문법으로 이해하기

  - ```sql
    SELECT *
    FROM (SELECT E.JOB, D.NAME
          FROM EMP E, DEPT D
          WHERE E.DEPTNO = D.DEPTNO)
    PIVOT (COUNT(*) FOR DNAME IN ('ACCOUNTING' AS ACCOUNTING,
                                  'RESEARCH' AS RESEARCH,
                                  'SALES' AS SALES));
    ```

- UNPIVOT: 열을 행으로 바꿈.

  - ```sql
    SELECT 계절, 연도, 기온
    FROM (SELECT * FROM 평균기온)
    UNPIVOT (기온 FOR 연도 IN (Y2018 AS '2018년',
                             Y2019 AS '2019년'));
    ```



### 정규표현식

- `[a-zA-Z]`: 문자그룹
  - `[^word]`: word를 포함하지 않음

- 반복
  - `+`: 패턴 1회 이상 반복
  - `*`: 패턴 0회 이상 반복
  - `{n, m}`: 패턴 n회 이상, m회 이하 반복
  - `{n}`: n회 반복
  - `{n, }`n회 이상 반복 
  - `?`: 0회 또는 1회 포함

- `.`: 자리 하나 차지
- `^word`: word로 시작하는 문자열
- `word$`: word로 끝나는 문자열



### REGEXP

- REGEXP_REPLACE(컬럼, 찾을문자열, [바꿀문자열], [검색위치], [발견횟수], [옵션]): 정규식 표현을 사용하여 문자열을 치환
  - 바꿀문자열 생략 시 문자열 삭제
  - 검색위치 생략 시 기본값 1
  - 발견 횟수 생략시 기본값 0(모든)
  - 옵션
    - c: 대소문자 구분하여 검색
    - i: 대소문자 구분하지 않고 검색
    - m: 패턴을 다중라인으로 선언가능
- REGEXP_SUBSTR(대상, 패턴, [검색위치], [발견횟수], [옵션], [추출그룹]): 문자열 추출
  - 검색위치 생략 시 기본값 1
  - 발견횐수 생략 시 기본값 0(모든)
  - 옵션
    - c: 대소문자 구분하여 검색
    - i: 대소문자 구분하지 않고 검색
    - m: 패턴을 다중라인으로 선언가능
  - 추출그룹은 서브 패턴을 추출 시 추출할 서브패턴 번호 입력
- REGEXP_INSTR(원본, 찾을문자열, [시작위치], [발견횟수]): 주어진 문자열에서 특정 패턴의 시작 위치 반환
  - 시작위치 생략 시 처음부터 확인. 기본값 1
  - 발견횟수 생략 시 처음 발견된 문자열 위치 리턴

- REGEXP_LIKE(원본, 찾을문자열, [옵션])
  - 옵션
    - c: 대소문자 구분하여 검색
    - i: 대소문자 구분하지 않고 검색
    - m: 패턴을 다중라인으로 선언가능

- REGEXP_COUNT(원본, 찾을문자열, [시작위치], [옵션]): 주어진 문자열에서 특정패턴의 횟수 반환
  - 시작위치 생략 시 기본값 1
  - 옵션
    - c: 대소문자 구분하여 검색
    - i: 대소문자 구분하지 않고 검색
    - m: 패턴을 다중라인으로 선언가능

